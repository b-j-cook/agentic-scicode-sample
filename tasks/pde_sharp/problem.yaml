# =============================================================================
# Task Definition
# =============================================================================
#
# This file defines your task's metadata and structure.
#
# WORKFLOW:
# 1. Review and edit all sections below
# 2. Edit steps/*.py - refine each sub-problem
# 3. (Optional) Edit background/*.md - add domain context
# 4. Run: task validate tasks/pde-sharp/
# 5. Run: task compile tasks/pde-sharp/
#
# =============================================================================


# TASK IDENTIFIER
# ---------------
# A unique name for your task. Use descriptive snake_case names.
# Examples: lennard_jones_potential, protein_folding, fft_implementation
problem_id: "pde_sharp"

# DISPLAY NAME
# ------------
# Human-readable title shown in listings and reports.
problem_name: "PDE-SHARP Solver"

# DOMAIN
# ------
# Category for organization (physics, chemistry, biology, mathematics)
domain: "mathematics"
# Subdomain for organization
# Mathematics: (Numerical Linear Algebra, Computational Mechanics)
# Physics: (Optics, Computational Physics, Quantum Information, Particle Physics)
# Chemistry: (Computational Chemistry)
# Material Science: (Semiconductor Materials)
# Biology: (Biochemistry)
subdomain: "computational mechanics"

# =============================================================================
# PROBLEM DESCRIPTION (shown to LLM as context)
# =============================================================================
# Describe the overall problem. This appears at the start of prompts.

description: |
  You are given a research paper describing a novel framework for constructing PDE solvers through a three-stage process (analysis, solver generation, and synthesis).

  Your task is to implement a PDE solver inspired by the PDE-SHARP framework described in the attached paper.

  The method is not a single numerical scheme, but is an algorihmic, multi-shot process that:
  - inspects a PDE (type, boundary conditions, stabillity constraints) and derive problem-specific structure and constraints to determine what valid, stable solvers should look like,
  - generates many candidate solvers that satisfy the constraints,
  - executes and evaluates each candidate solver and then iteratively refine and hybridize the best ones


# =============================================================================
# I/O SPECIFICATION (shown to LLM)
# =============================================================================
# Document the overall input/output contract. This helps the model understand
# what data types and formats to expect.

io_spec: |
  """
  PDE-SHARP Solver

  Solves partial differential equations using a three-stage framework:
  analysis, genesis (grid setup), and synthesis (candidate evaluation).

  Parameters
  ----------
  pde_description : dict
      Dictionary specifying the PDE structure with keys:
      - 'type': str, one of 'poisson_2d' or 'convection_diffusion_2d'
      - 'linear': bool, optional (default True)

  grid : np.ndarray
      Discretization grid, shape (2, Ny, Nx) where:
      - grid[0] contains X coordinates (meshgrid output)
      - grid[1] contains Y coordinates (meshgrid output)

  boundary_conditions : dict
      Boundary condition specification with keys:
      - 'values': dict with 'left', 'right', 'bottom', 'top' (scalars or arrays)
      - 'type': str, optional (e.g., 'dirichlet')

  parameters : dict
      Algorithmic hyperparameters. Contents depend on PDE type:
      For Poisson: 'source' (np.ndarray, shape NyÃ—Nx), 'refinement_rounds' (int)
      For convection-diffusion: 'dt' (float), 'num_steps' (int), 
          'velocity' (np.ndarray, shape 2), 'viscosity' (float), 'source' (np.ndarray)

  Returns
  -------
  solution : np.ndarray
      Numerical solution array, shape (Ny, Nx), representing the best 
      solution found across all candidate numerical schemes.
  """


# =============================================================================
# DEPENDENCIES
# =============================================================================
# Python imports available to the model. These are prepended to generated code.

dependencies:
  - import numpy as np
  - import jax
  - import jax.numpy as jnp
  - from jax import jit
  - from functools import partial
  - from typing import Dict, Tuple, List, Callable


# =============================================================================
# STEPS
# =============================================================================
# List of step files in order (without .py extension).
# Each step should have a corresponding file: steps/01_step_name.py
# Steps are solved sequentially - later steps can use earlier functions.

steps:
  - 01_setup_grid
  - 02_initialize_solution
  - 03_apply_boundary_conditions
  - 04_evaluate_candidate_poisson
  - 05_evaluate_candidate_convection_diffusion
  - 06_genesis_solver
  - 07_synthesize_solver
  - 08_pde_sharp_solve


# =============================================================================
# BACKGROUND (OPTIONAL)
# =============================================================================
# Overall background shown when with_background=True.
# Leave empty or delete if not needed.

background_main: |
  The PDE-SHARP framework implements a three-stage process for solving partial 
  differential equations:

  1. **Analysis**: Classify the PDE type (elliptic, parabolic, hyperbolic), determine 
     linearity, and analyze stability constraints (e.g., CFL conditions for 
     time-dependent problems).

  2. **Genesis**: Set up the discretization grid, select appropriate numerical 
     discretization methods (finite difference, stencil type), initialize the solution 
     field, and apply boundary conditions.

  3. **Synthesis**: Generate candidate numerical schemes, evaluate each scheme's 
     performance, and select the best solution through iterative refinement.

  Key concepts:
  - **Elliptic PDEs** (e.g., Poisson): Steady-state problems, typically solved with 
    iterative methods like Jacobi, Gauss-Seidel, or SOR (Successive Over-Relaxation).
  - **Parabolic PDEs** (e.g., convection-diffusion): Time-dependent problems requiring 
    time-stepping schemes with stability constraints. Common schemes include upwind 
    differencing, central differences, and implicit methods.
  - **Stability constraints**: For time-dependent problems, the time step must satisfy 
    CFL (Courant-Friedrichs-Lewy) conditions to ensure numerical stability.
  - **Boundary conditions**: Dirichlet (fixed values) or Neumann (fixed derivatives) 
    conditions applied at domain boundaries.
